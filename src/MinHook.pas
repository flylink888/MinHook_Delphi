unit MinHook;
{ ************************************************************************** }
{ }
{ This C DLL header file first (automatic) conversion generated by: }
{ HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com) }
{ Final Delphi-Jedi (Darth) command-line units edition }
{ }
{ Generated Date:   2020/5/7 }
{ Generated Time: 11:08:51 }
{ }
{ ************************************************************************** }

interface

uses
  Windows;

{ +// }
{ -* MinHook - The Minimalistic API Hooking Library for x64/x86 }
{ -* Copyright (C) 2009-2017 Tsuda Kageyu. }
{ -* All rights reserved. }
{ -* }
{ -* Redistribution and use in source and binary forms, with or without }
{ -* modification, are permitted provided that the following conditions }
{ -* are met: }
{ -* }
{ -* 1. Redistributions of source code must retain the above copyright }
{ -* notice, this list of conditions and the following disclaimer. }
{ -* 2. Redistributions in binary form must reproduce the above copyright }
{ -* notice, this list of conditions and the following disclaimer in the }
{ -* documentation and/or other materials provided with the distribution. }
{ -* }
{ -* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS }
{ -* "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED }
{ -* TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A }
{ -* PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER }
{ -* OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, }
{ -* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, }
{ -* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR }
{ -* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF }
{ -* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING }
{ -* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS }
{ -* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. }
{ = }

type
  MH_STATUS = (
    // Unknown error. Should not be returned.
    MH_UNKNOWN = -1,

    // Successful.
    MH_OK = 0,

    // MinHook is already initialized.
    MH_ERROR_ALREADY_INITIALIZED,

    // MinHook is not initialized yet, or already uninitialized.
    MH_ERROR_NOT_INITIALIZED,

    // The hook for the specified target function is already created.
    MH_ERROR_ALREADY_CREATED,

    // The hook for the specified target function is not created yet.
    MH_ERROR_NOT_CREATED,

    // The hook for the specified target function is already enabled.
    MH_ERROR_ENABLED,

    // The hook for the specified target function is not enabled yet, or already
    // disabled.
    MH_ERROR_DISABLED,

    // The specified pointer is invalid. It points the address of non-allocated
    // and/or non-executable region.
    MH_ERROR_NOT_EXECUTABLE,

    // The specified target function cannot be hooked.
    MH_ERROR_UNSUPPORTED_FUNCTION,

    // Failed to allocate memory.
    MH_ERROR_MEMORY_ALLOC,

    // Failed to change the memory protection.
    MH_ERROR_MEMORY_PROTECT,

    // The specified module is not loaded.
    MH_ERROR_MODULE_NOT_FOUND,

    // The specified function is not found.
    MH_ERROR_FUNCTION_NOT_FOUND);

  { /// Can be passed as a parameter to MH_EnableHook, MH_DisableHook, }
  { /// MH_QueueEnableHook or MH_QueueDisableHook. }
var
  MH_ALL_HOOKS: Pointer = nil;

  { /// Initialize the MinHook library. You must call this function EXACTLY ONCE }
  { /// at the beginning of your program. }
var
  MH_Initialize: function: MH_STATUS stdcall;

  { /// Uninitialize the MinHook library. You must call this function EXACTLY }
  { /// ONCE at the end of your program. }
var
  MH_Uninitialize: function: MH_STATUS stdcall;

  { /// Creates a Hook for the specified target function, in disabled state. }
  { /// Parameters: }
  { /// pTarget [in] A pointer to the target function, which will be }
  { /// overridden by the detour function. }
  { /// pDetour [in] A pointer to the detour function, which will override }
  { /// the target function. }
  { /// ppOriginal [out] A pointer to the trampoline function, which will be }
  { /// used to call the original target function. }
  { /// This parameter can be NULL. }
var
  MH_CreateHook: function(pTarget: Pointer; pDetour: Pointer;
    var pOriginal: Pointer): MH_STATUS stdcall;

  { /// Creates a Hook for the specified API function, in disabled state. }
  { /// Parameters: }
  { /// pszModule [in] A pointer to the loaded module name which contains the }
  { /// target function. }
  { /// pszTarget [in] A pointer to the target function name, which will be }
  { /// overridden by the detour function. }
  { /// pDetour [in] A pointer to the detour function, which will override }
  { /// the target function. }
  { /// ppOriginal [out] A pointer to the trampoline function, which will be }
  { /// used to call the original target function. }
  { /// This parameter can be NULL. }
var
  MH_CreateHookApi: function(pszModule: PChar; pszProcName: PAnsiChar;
    pDetour: Pointer; var pOriginal: Pointer): MH_STATUS stdcall;

  { /// Creates a Hook for the specified API function, in disabled state. }
  { /// Parameters: }
  { /// pszModule [in] A pointer to the loaded module name which contains the }
  { /// target function. }
  { /// pszTarget [in] A pointer to the target function name, which will be }
  { /// overridden by the detour function. }
  { /// pDetour [in] A pointer to the detour function, which will override }
  { /// the target function. }
  { /// ppOriginal [out] A pointer to the trampoline function, which will be }
  { /// used to call the original target function. }
  { /// This parameter can be NULL. }
  { /// ppTarget [out] A pointer to the target function, which will be used }
  { /// with other functions. }
  { /// This parameter can be NULL. }
var
  MH_CreateHookApiEx: function(pszModule: PChar; pszProcName: PAnsiChar;
    pDetour: Pointer; var pOriginal: Pointer; var pTarget: Pointer)
    : MH_STATUS stdcall;

  { /// Removes an already created hook. }
  { /// Parameters: }
  { /// pTarget [in] A pointer to the target function. }
var
  MH_RemoveHook: function(pTarget: Pointer): MH_STATUS stdcall;

  { /// Enables an already created hook. }
  { /// Parameters: }
  { /// pTarget [in] A pointer to the target function. }
  { /// If this parameter is MH_ALL_HOOKS, all created hooks are }
  { /// enabled in one go. }
var
  MH_EnableHook: function(pTarget: Pointer): MH_STATUS stdcall;

  { /// Disables an already created hook. }
  { /// Parameters: }
  { /// pTarget [in] A pointer to the target function. }
  { /// If this parameter is MH_ALL_HOOKS, all created hooks are }
  { /// disabled in one go. }
var
  MH_DisableHook: function(pTarget: Pointer): MH_STATUS stdcall;

  { /// Queues to enable an already created hook. }
  { /// Parameters: }
  { /// pTarget [in] A pointer to the target function. }
  { /// If this parameter is MH_ALL_HOOKS, all created hooks are }
  { /// queued to be enabled. }
var
  MH_QueueEnableHook: function(pTarget: Pointer): MH_STATUS stdcall;

  { /// Queues to disable an already created hook. }
  { /// Parameters: }
  { /// pTarget [in] A pointer to the target function. }
  { /// If this parameter is MH_ALL_HOOKS, all created hooks are }
  { /// queued to be disabled. }
var
  MH_QueueDisableHook: function(pTarget: Pointer): MH_STATUS stdcall;

  { /// Applies all queued changes in one go. }
var
  MH_ApplyQueued: function: MH_STATUS stdcall;

  { /// Translates the MH_STATUS to its name as a string. }
var
  MH_StatusToString: function(var status: MH_STATUS): PChar stdcall;

var
  DLLLoaded: Boolean { is DLL (dynamically) loaded already? }
    = False;

implementation

var
  SaveExit: Pointer;
  DLLHandle: THandle;

procedure NewExit; far;
begin
  ExitProc := SaveExit;
  FreeLibrary(DLLHandle)
end { NewExit };

procedure LoadDLL;
begin
  if DLLLoaded then
    Exit;
  DLLHandle := LoadLibrary('MinHook.dll');
  if DLLHandle >= 32 then
  begin
    DLLLoaded := True;
    SaveExit := ExitProc;
    ExitProc := @NewExit;
    @MH_Initialize := GetProcAddress(DLLHandle, 'MH_Initialize');
    Assert(@MH_Initialize <> nil);

    @MH_Uninitialize := GetProcAddress(DLLHandle, 'MH_Uninitialize');
    Assert(@MH_Uninitialize <> nil);

    @MH_CreateHook := GetProcAddress(DLLHandle, 'MH_CreateHook');
    Assert(@MH_CreateHook <> nil);

    @MH_CreateHookApi := GetProcAddress(DLLHandle, 'MH_CreateHookApi');
    Assert(@MH_CreateHookApi <> nil);

    @MH_CreateHookApiEx := GetProcAddress(DLLHandle, 'MH_CreateHookApiEx');
    Assert(@MH_CreateHookApiEx <> nil);

    @MH_RemoveHook := GetProcAddress(DLLHandle, 'MH_RemoveHook');
    Assert(@MH_RemoveHook <> nil);

    @MH_EnableHook := GetProcAddress(DLLHandle, 'MH_EnableHook');
    Assert(@MH_EnableHook <> nil);

    @MH_DisableHook := GetProcAddress(DLLHandle, 'MH_DisableHook');
    Assert(@MH_DisableHook <> nil);

    @MH_QueueEnableHook := GetProcAddress(DLLHandle, 'MH_QueueEnableHook');
    Assert(@MH_QueueEnableHook <> nil);

    @MH_QueueDisableHook := GetProcAddress(DLLHandle, 'MH_QueueDisableHook');
    Assert(@MH_QueueDisableHook <> nil);

    @MH_ApplyQueued := GetProcAddress(DLLHandle, 'MH_ApplyQueued');
    Assert(@MH_ApplyQueued <> nil);

    @MH_StatusToString := GetProcAddress(DLLHandle, 'MH_StatusToString');
    Assert(@MH_StatusToString <> nil);
  end
  else
  begin
    DLLLoaded := False;
    { Error: MINHOOK.DLL could not be loaded !! }
  end;

end;

begin
  LoadDLL;

end.
